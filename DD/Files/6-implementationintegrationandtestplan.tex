\section{Implementation, integration and test plan}
\label{sect:implementationintegrationandtestplan}

\subsection{Entry Criteria}
\label{subsect: entrycriteria}
Components should be tested as soon as they are released. Though, some preliminary conditions have to be satisfied before the integration plan testing shall be put into pratice.
Such preconditions are:
\begin{itemize}
    \item all of the people involved in this process must come prepared to the meetings of the peer review. This means that they have previously and carefully read the RASD and this very same document.
    \item Some of the low level modules must be avaible in order to properly test some of the components of our system. Such low level modules consists in:
        \begin{itemize}
            \item All of the DBMS must have been configured and the DBs - Shop Database, Queue Database and Account Database- possibly prefilled with fictitious data
            \item For the integration test regarding the Shop Services Subsystem, and in particular, the Shop Info Component, the Maps API should be avaible and fully usable.
            \item In order to test the part of the QR-code scanner application implemented by us, the underlaying application, the one that assures the correct unlock and lock of the turnstills, must be avaible and correctly functioning. 
            \item To proceed with the testing and integration of the Notificate User Component, which is part of the Queue Service Subsytem, the Push Api must be fully operative.
            \item To test and integrate the Account Manager Services Subsystem, the SMS Gateway should be avaible and ready to use.
        \end{itemize}
        \item In order to test a component and its interactions with other components, it must have reached a minimum level of satifistaction of its goals and functionalities. To be more precise, we will indicate the minium level of complection of each component in order for it to take part of the integration and testing plan:
        \begin{itemize}
            \item 60 \% of the Account Manager Component
            \item 60 \% of the Authorization and Authentication Engine Component
            \item 80 \% of the Ticket Generator 
            Component
            \item 90 \% of the Ticket Scheduler Component
            \item 70 \% of the Visit Component
            \item 70 \% of the LineUp Component
            \item  60 \% of the Queue Info Component
            \item  60 \% of the Analytics Component
            \item 80 \% of the Shop Info Component
            \item 70 \% of the Manage Shop Component
            \item 80 \% of all of the different Data Manager Component present in all of the subsystem
        \end{itemize}
        The different percentage of complection are due to the role of the component in the system. The most significant the features it offers are for the application, the higher the percentage is. Also the level of criticality of the algorithms implements by a component along with the level of its interconnection with other components have been considered for deciding the level of complection.
\end{itemize}


\subsection{Elements To Be Integrated}
\label{subsect: entrycriteria}
The component that must be tested and integrated can be divideed in three main categories:
-Front-end components: Qr-code Scanner Application, Web Application, Mobile Application 
-Back-end components: Queue Services Subsystem, Shop Services Subsystem, Account Management Subsystem
-External Components: Qr-code underlaying application, SMS GateWay, DBMS, Push API, Maps API

There are two kind of integration to perform. The first integration is the integration between components that are part of the same category.
In this category we can find the integration that have to be performed within the front-end components and the back-end components internally with respect to their subsystems.
The second kind of integration concerns the integration externally to their subsystems.

Front-end components and external components are indipendent from each other, while back-end components must be integrated either with front-end components and external-components.

 Due to this architecture, it is possible to partially test first each component of a category, integrate them with other components of their same category and finally integrate all of the system.

 The main integration of the back-end components with the front-end components are:

 \begin{itemize}
    \item \textbf{Mobile Application, Queue Services}
    \item \textbf{Mobile Application, Shop Services}
    \item \textbf{Mobile Application, Account Manager Services}
    \item \textbf{Mobile Application, PUSH API}
    \item \textbf{Web Application, Queue Services}
    \item \textbf{Web Application, Shop Services}
    \item \textbf{Web Application, Account Manager Services}
    \item \textbf{QR-code scanner Application, Queue Services}
 \end{itemize}

 The main integration of the back-end components with the external components are:

 \begin{itemize}
    \item \textit{Queue Services Subsystem}
    \begin{itemize}    
        \item \textbf{Queue Services, Queue DBMS}
        \item \textbf{Queue Services, PUSH API}
        \item \textbf{Queue Services, Qr-code scanner Application} ( this is inted as external to the component....)
    \end{itemize}
    \item \textit{Shop Services Subsystem}
     \begin{itemize}  
        \item \textbf{Shop Services, Shop DBMS}
        \item \textbf{Shop Services, MAPS API}
     \end{itemize}
     \item \textit{Shop Services Subsystem}
     \begin{itemize}  
        \item \textbf{Account Manager Services, Account DBMS}
     \end{itemize}  
 \end{itemize}

 \subsection{Integration Testing Strategy}
\label{subsect:integrationtestingstrategy}
According to what previously stated and in agreement with the nature of the application we are going to develop, we decided to test our system following a bottom up approach in combination with critical modules.\newline
Thus, we decided to implement in first instance the QueueScheduler Component, which is the core module of our application, and, indeed, the most critical and delicate one. After this component is fully functional and tested, it will be possible to proceed all of the other components that some one gravitates around it with a thread-based integration. In the thread-based integration, the external dependencies will be integrated before the others: the bottom-up approach is intended this way.\newline
This way, it will be possible to parallelize the developement phase and, moreover, to have more of an immediate feedback also at UX level. Further more, using this approach, the effort spent in providing stubs and drivers will be minimal.

\subsection{Sequence of Component Integration}
\label{subsect:integrationtestingstrategy}
In this section we will describe the order of integration of components and subsystems.
As a notation, an arrow going from a A to B means that B needs A in order to be tested, so that A needs to have been previously implemented.

\subsubsection{Software Integration sequence}
\label{subsect: softwareintegrationsequence}

\subsubsection*{Queue Services}

\begin{itemize}
    \item \textbf{External Dependencies}
    all of the components in this subsystem depends on the Data Managar, which, in turn, depends on the DBMS. Furthermoer, the \textit{Notification User} component depends on the Push Api, while the \textit{Qr-code scanner} component depends on the Qr-code scanner application.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Queue/ExternalDepDBMS.png}
        \caption{\label{fig:QueueExternalDepDBMS}{Queue DBMS depencency}}
    \end{figure}
    \FloatBarrier  
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Queue/ExternalDepPUSH.png}
        \caption{\label{fig:QueueExternalDepPUSH}{PUSH API depencency}}
    \end{figure}
    \FloatBarrier  
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Queue/ExternalDepQRCOMPO.png}
        \caption{\label{fig:QueueExternalDepQRCOMPO}{Qr-code scanner application depencency}}
    \end{figure}
    \FloatBarrier 
   \item \textbf{Internal progressive component integration}
   Here it is shown the progressive integration of the components internal to the subsystem. The order of integration has been chosen due to the dependencies intra components. the \textit{Ticket Scheduler Component } and the \textit{Ticket Generator Component} have been colored in red because a particular attention need to be paid while developing and testing them due to their critical role in the application.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.6\textwidth]{Images/TestDiagram/Queue/queueserviceprogressive/2-0.png}
        \caption{\label{fig:QueueInternal2}{Progressive Integration 1}}
    \end{figure}
    \FloatBarrier 
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.6\textwidth]{Images/TestDiagram/Queue/queueserviceprogressive/2-1.png}
        \caption{\label{fig:QueueInternal2.1}{Progressive Integration 2}}
    \end{figure}
    \FloatBarrier 
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.9\textwidth]{Images/TestDiagram/Queue/queueserviceprogressive/3.png}
        \caption{\label{fig:QueueInternal3}{Progressive Integration 3}}
    \end{figure}
    \FloatBarrier     
\end{itemize}

\subsubsection*{Shop Services}

\begin{itemize}
    \item \textbf{External Dependencies}
    all of the components in this subsystem depends on the Data Managar, which, in turn, depends on the DBMS. Furthermoer, the \textit{Shop Info Component}  depends on the Maps Api component.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Shop/maps.png}
        \caption{\label{fig:ShopExternalDepMAPS}{Maps API depencency}}
    \end{figure}
    \FloatBarrier  
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Shop/data.png}
        \caption{\label{fig:ShopExternalDepDBMS}{Shop DBMS depencency}}
    \end{figure}
    \FloatBarrier
    \item \textbf{Internal progressive components integration} 
    Here it is shown the progressive integration of the components internal to the subsystem.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=1\textwidth]{Images/TestDiagram/Shop/2Shop(1).png}
        \caption{\label{fig:Shopinternal}{Shop Progressive 1}}
    \end{figure}
    \FloatBarrier  
\end{itemize}

\subsubsection*{Account ManagerServices}
\begin{itemize}
    \item \textbf{External Dependencies}
    all of the components in this subsystem depends on the Data Managar, which, in turn, depends on the DBMS. Furthermoer, the \textit{Account Manager Component}  depends on the SMS Gateway component.
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Account/ExternalDependenciesDBMS.png}
        \caption{\label{fig:AccountExternalDepDBMS}{Account DBMS depencency}}
    \end{figure}
    \FloatBarrier  
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=.8\textwidth]{Images/TestDiagram/Account/ExternalDependenciesSMS.png}
        \caption{\label{fig:AccountExternalDepSMS}{SMS Gateway depencency}}
    \end{figure}
    \FloatBarrier  
    \textbf{Internal progressive components integration}
    the following images shows the progressive integration of the components internal to the subsystem
        \begin{figure}[h!]
        \centering
        \includegraphics[width=1\textwidth]{Images/TestDiagram/Account/subAccount1.png}
        \caption{\label{fig:progressiveAccount1}{progressive sequence 1}}
    \end{figure}
    \FloatBarrier 
    \begin{figure}[h!]
        \centering
        \includegraphics[width=1\textwidth]{Images/TestDiagram/Account/subAccount2.png}
        \caption{\label{fig:progressiveAccount1}{progressive sequence 2}}
    \end{figure}
    \FloatBarrier 

\end{itemize}


\subsubsection{Subsystem Integration Sequence}
\label{subsect: subsytemintegrationsequence}

The following diagrams present the integration of the subsytems with the front-end components. In this diagram, it have been chosen, for the sake of simplicity, to represent the Front-end as a cross-platform subsystem. 

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Images/TestDiagram/view.png}
    \caption{\label{fig:viewQueue}{integration Queue Service Subsystem with front-end component}}
\end{figure}
\FloatBarrier 
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Images/TestDiagram/viewAccount.png}
    \caption{\label{fig:viewAccount}{integration Account Manager Subsystem with front-end component}}
\end{figure}
\FloatBarrier 
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Images/TestDiagram/viewShop.png}
    \caption{\label{fig:viewAccount}{integration Shop Services Subsystem with front-end component}}
\end{figure}
\FloatBarrier 


Finally, once all of the subsystems are fully integrated, we are ready to put together, ready for deployment, the Clup Application. Here we decided to split the front end subystem into its component, in order to have a complete representation of all of the components of the System.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Images/TestDiagram/whole application.png}
    \caption{\label{fig:wholeapp}{System integration}}
\end{figure}
\FloatBarrier 

\subsection{System Testing}
The System testing will be conducted by indipendent teams in order for the functional and non functional requirements of our application to be verified.
The type of tests we have selected in order test our applications are the following:
\begin{itemize}
    \item \textbf{Performance Testing}: performance testing will be performed in order to indentify the bottlenecks of our system which may affect the usability of our application. Benchmarking will be used too: this means that comparable data coming from similiar applications already present on the market will be retrieved and compared with our results.
    \item \textbf{Load Testing}: this kind of testing will help us identify the main problem relativly to the management of the avaible memory and to identify the components which needs upper limits constraints. This kind of testing will be performed gradually increasing the load on the system till a threshold is reached and also by loading the system with maximum load it can support for a long period of time.
    \item \textbf{Stress Testing}: this kind of testing is performed in order to be sure that the system is able recover quickly and correctly after a failure event. The way we are going to implements this kind of testing is by trying to break the system, for exemple by overwhelming it or by subtracting resources from it.
\end{itemize}







